# C#数学运算相关开发性能优化指导原则

华为公司的[C语言编程规范](https://ilcc.gitbooks.io/wiki/content/StyleGuide/Huawei-C/index.html)的开头就强调了：
> 一般情况下，代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化。

本文讲述的原则也没有经过大项目和大公司的检验，所以，请批判性地阅读本文。本文中的大部分结论有测试代码支持，参见SpeedTest.cs. 虽然C#的编译器会在release版本中执行一些优化，C#的运行时也有一些优化，但偶尔会遇到debug版本正常，而release版本异常的问题，比如我在github上fork了已停止维护的屏幕录像软件[Captura](https://github.com/FrogGuaGuaGua/Captura)，debug模式能启动，release版本无法启动，我短时间内解决不了这个问题，如果要发布，只能发布debug版本。所以手工执行一些虽然编译器(在release版本中)会做但也简单易读的优化，还是有意义的。同时建议把未经优化的代码作为注释附在旁边，提高可读性。

1. const, readonly, in 这3个关键词在能用的地方要尽量用。这样可以让编译器执行更激进的优化策略，同时提高代码的安全性、可读性和可维护性。
2. 整数乘以或除以$2^n$ (n也是整数)，使用移位来代替。但对乘除非 $2^n$ 的整数不要使用此方法，比如不要把 i * 12 改写成 (i << 2 + i << 3).

20. 除以浮点型常数的除法，改写为乘以这个数的倒数。比如把 x / 2.0 改写为 x * 0.5  .

30. 绝大多数情况下都应该使用double型浮点数，避免使用float型。因为新出的电脑和手机都是64位处理器，都有硬件浮点单元，并针对double型进行了额外的优化，float型的计算速度有时甚至比double型更慢。如果没有大量的浮点数参与运算或需要存储，float型节省存储空间的优势也没有意义。float型的精度太差，可能带来一些难以察觉的bug，比如 for(float i = 0.0f; i < 20_000_000; i++){} 就是一个难以察觉的死循环，当 i 达到 $2^{24}=16777216$ 时，会由于float的精度太低，无法区分16777216和16777217，即无法自增1. 另外，使用float型，所有的字面量都要加 f 后缀，所有的Math库函数前面都要加(float)进行强制类型转换(或者使用MathF库中的函数)，写起来麻烦，看起来丑陋，所以要尽量避免。在以下情形(但不限于)可考虑使用float型：
    * 训练AI模型，数据量巨大但对计算精度要求不高，float型可显著节省存储空间。
    * 程序要在32位处理器上运行，或者要在没有硬件浮点单元的处理器上运行。	

40. 计算$x^n$，当$n=2,3$时，不要使用Math.Pow(x,n), 而是直接写成 x * x 和 x * x * x. 当 n 取其它值时才可调用Math.Pow.

50. 引入一些额外的变量来存储函数调用的结果，或者复杂运算过程中的子过程的值，避免重复调用和计算。比如计算二维坐标旋转: $ x'=x\cos\theta-y\sin\theta,\ y'=x\sin\theta+y\cos\theta$，同一个角的正弦和余弦值都要使用两次。一元二次方程求根，$\frac{\sqrt{\Delta}}{2a}$会使用两次。二元一次方程求根，系数矩阵的行列式值会使用两次。在循环中如果要以同样的参数调用某个函数，或者有一些不随循环变化的子过程，则应提到循环外部，用变量存储。

60. 对浮点数进行取整操作时，如果确定浮点数的大小不超出int(或long)型的范围，以及不会出现NaN，则可以用强制类型转换结合条件语句替代Floor、Ceiling和Round函数，显著提高速度。使用 (int)(t $\pm $ 0.5) 来代替Math.Round(t)则需谨慎，因为当t的小数部分为0.5时，Round(t)的结果取决于中点值舍入模式的设定，默认是MidpointRounding.ToEven，即向最近的偶数舍入。其它模式还有ToZero, AwayFromZero, ToNegativeInfinity, ToPositiveInfinity. 要根据不同的舍入模式选择不同的替代写法。
```C#
	// 替代 a = (int)Math.Floor(t)
	a = (t < 0 ? (int)t - 1 : (int)t);

	// 替代 b = (int)Math.Ceiling(t)
	b = (t < 0 ? (int)t : (int)t + 1);

	// 替代 c = (int)Math.Round(t, MidpointRounding.ToZero)
	c = (t < 0 ? (int)(t - 0.5) : (int)(t + 0.5));
``` 

8. 对于Array of Struct和Struct of Array两种数据结构，

80. 模式匹配

90. 尽量避免编写含递归调用的函数。比如阶乘函数，应该使用循环来实现，而不是递归。而且由于阶乘函数增长太快，
    $13!>2^{32}$ = 4294967296 = uint.MaxValue
	$21!>2^{64}$ = 18446744073709551616 = ulong.MaxValue
	$35!>2^{128}$ = float.MaxValue
	$171!>2^{1024}$ = double.MaxValue
在大多数情况下，阶乘函数允许的参数的范围很小，可以直接做成常数数组存储，访问数组比其它任何算法都快。C#开源数学库MathNet Numerics中的阶乘函数就是使用了含171个double型元素的数组。
```C#
static readonly int[] Factorial = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600];
static readonly long[] FactorialL = [1L, 1L, 2L, 6L, 24L, 120L, 720L, 5040L, 40320L, 362880L, 3628800L, 39916800L,
			479001600L, 6227020800L, 87178291200L, 1307674368000L, 20922789888000L,
			355687428096000L, 6402373705728000L, 121645100408832000L, 2432902008176640000L];
```


90.  Math.NET Numerics、Accord.NET 和 ILNumerics 

 避免在循环中创建对象。避免在循环中反复打开和关闭同一个文件。

 https://www.cnblogs.com/hez2010/p/13724904.html
 https://www.cnblogs.com/blqw/p/3619132.html

